import chalk from 'chalk';
import os from 'os';
import tty from 'tty';
import envinfo from 'envinfo';
import fetch from 'node-fetch';
import { dirname } from 'path';
import pkgUp from 'pkg-up';
import { readFileSync } from 'fs';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

const ESC = '\u001B[';
const OSC = '\u001B]';
const BEL = '\u0007';
const SEP = ';';
const isTerminalApp = process.env.TERM_PROGRAM === 'Apple_Terminal';

const ansiEscapes = {};

ansiEscapes.cursorTo = (x, y) => {
	if (typeof x !== 'number') {
		throw new TypeError('The `x` argument is required');
	}

	if (typeof y !== 'number') {
		return ESC + (x + 1) + 'G';
	}

	return ESC + (y + 1) + ';' + (x + 1) + 'H';
};

ansiEscapes.cursorMove = (x, y) => {
	if (typeof x !== 'number') {
		throw new TypeError('The `x` argument is required');
	}

	let returnValue = '';

	if (x < 0) {
		returnValue += ESC + (-x) + 'D';
	} else if (x > 0) {
		returnValue += ESC + x + 'C';
	}

	if (y < 0) {
		returnValue += ESC + (-y) + 'A';
	} else if (y > 0) {
		returnValue += ESC + y + 'B';
	}

	return returnValue;
};

ansiEscapes.cursorUp = (count = 1) => ESC + count + 'A';
ansiEscapes.cursorDown = (count = 1) => ESC + count + 'B';
ansiEscapes.cursorForward = (count = 1) => ESC + count + 'C';
ansiEscapes.cursorBackward = (count = 1) => ESC + count + 'D';

ansiEscapes.cursorLeft = ESC + 'G';
ansiEscapes.cursorSavePosition = isTerminalApp ? '\u001B7' : ESC + 's';
ansiEscapes.cursorRestorePosition = isTerminalApp ? '\u001B8' : ESC + 'u';
ansiEscapes.cursorGetPosition = ESC + '6n';
ansiEscapes.cursorNextLine = ESC + 'E';
ansiEscapes.cursorPrevLine = ESC + 'F';
ansiEscapes.cursorHide = ESC + '?25l';
ansiEscapes.cursorShow = ESC + '?25h';

ansiEscapes.eraseLines = count => {
	let clear = '';

	for (let i = 0; i < count; i++) {
		clear += ansiEscapes.eraseLine + (i < count - 1 ? ansiEscapes.cursorUp() : '');
	}

	if (count) {
		clear += ansiEscapes.cursorLeft;
	}

	return clear;
};

ansiEscapes.eraseEndLine = ESC + 'K';
ansiEscapes.eraseStartLine = ESC + '1K';
ansiEscapes.eraseLine = ESC + '2K';
ansiEscapes.eraseDown = ESC + 'J';
ansiEscapes.eraseUp = ESC + '1J';
ansiEscapes.eraseScreen = ESC + '2J';
ansiEscapes.scrollUp = ESC + 'S';
ansiEscapes.scrollDown = ESC + 'T';

ansiEscapes.clearScreen = '\u001Bc';

ansiEscapes.clearTerminal = process.platform === 'win32' ?
	`${ansiEscapes.eraseScreen}${ESC}0f` :
	// 1. Erases the screen (Only done in case `2` is not supported)
	// 2. Erases the whole screen including scrollback buffer
	// 3. Moves cursor to the top-left position
	// More info: https://www.real-world-systems.com/docs/ANSIcode.html
	`${ansiEscapes.eraseScreen}${ESC}3J${ESC}H`;

ansiEscapes.beep = BEL;

ansiEscapes.link = (text, url) => {
	return [
		OSC,
		'8',
		SEP,
		SEP,
		url,
		BEL,
		text,
		OSC,
		'8',
		SEP,
		SEP,
		BEL
	].join('');
};

ansiEscapes.image = (buffer, options = {}) => {
	let returnValue = `${OSC}1337;File=inline=1`;

	if (options.width) {
		returnValue += `;width=${options.width}`;
	}

	if (options.height) {
		returnValue += `;height=${options.height}`;
	}

	if (options.preserveAspectRatio === false) {
		returnValue += ';preserveAspectRatio=0';
	}

	return returnValue + ':' + buffer.toString('base64') + BEL;
};

ansiEscapes.iTerm = {
	setCwd: (cwd = process.cwd()) => `${OSC}50;CurrentDir=${cwd}${BEL}`,

	annotation: (message, options = {}) => {
		let returnValue = `${OSC}1337;`;

		const hasX = typeof options.x !== 'undefined';
		const hasY = typeof options.y !== 'undefined';
		if ((hasX || hasY) && !(hasX && hasY && typeof options.length !== 'undefined')) {
			throw new Error('`x`, `y` and `length` must be defined when `x` or `y` is defined');
		}

		message = message.replace(/\|/g, '');

		returnValue += options.isHidden ? 'AddHiddenAnnotation=' : 'AddAnnotation=';

		if (options.length > 0) {
			returnValue +=
					(hasX ?
						[message, options.length, options.x, options.y] :
						[options.length, message]).join('|');
		} else {
			returnValue += message;
		}

		return returnValue + BEL;
	}
};

var hasFlag = (flag, argv = process.argv) => {
	const prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');
	const position = argv.indexOf(prefix + flag);
	const terminatorPosition = argv.indexOf('--');
	return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
};

const {env} = process;

let forceColor;
if (hasFlag('no-color') ||
	hasFlag('no-colors') ||
	hasFlag('color=false') ||
	hasFlag('color=never')) {
	forceColor = 0;
} else if (hasFlag('color') ||
	hasFlag('colors') ||
	hasFlag('color=true') ||
	hasFlag('color=always')) {
	forceColor = 1;
}

if ('FORCE_COLOR' in env) {
	if (env.FORCE_COLOR === 'true') {
		forceColor = 1;
	} else if (env.FORCE_COLOR === 'false') {
		forceColor = 0;
	} else {
		forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
	}
}

function translateLevel(level) {
	if (level === 0) {
		return false;
	}

	return {
		level,
		hasBasic: true,
		has256: level >= 2,
		has16m: level >= 3
	};
}

function supportsColor(haveStream, streamIsTTY) {
	if (forceColor === 0) {
		return 0;
	}

	if (hasFlag('color=16m') ||
		hasFlag('color=full') ||
		hasFlag('color=truecolor')) {
		return 3;
	}

	if (hasFlag('color=256')) {
		return 2;
	}

	if (haveStream && !streamIsTTY && forceColor === undefined) {
		return 0;
	}

	const min = forceColor || 0;

	if (env.TERM === 'dumb') {
		return min;
	}

	if (process.platform === 'win32') {
		// Windows 10 build 10586 is the first Windows release that supports 256 colors.
		// Windows 10 build 14931 is the first release that supports 16m/TrueColor.
		const osRelease = os.release().split('.');
		if (
			Number(osRelease[0]) >= 10 &&
			Number(osRelease[2]) >= 10586
		) {
			return Number(osRelease[2]) >= 14931 ? 3 : 2;
		}

		return 1;
	}

	if ('CI' in env) {
		if (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI', 'GITHUB_ACTIONS', 'BUILDKITE'].some(sign => sign in env) || env.CI_NAME === 'codeship') {
			return 1;
		}

		return min;
	}

	if ('TEAMCITY_VERSION' in env) {
		return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
	}

	if (env.COLORTERM === 'truecolor') {
		return 3;
	}

	if ('TERM_PROGRAM' in env) {
		const version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);

		switch (env.TERM_PROGRAM) {
			case 'iTerm.app':
				return version >= 3 ? 3 : 2;
			case 'Apple_Terminal':
				return 2;
			// No default
		}
	}

	if (/-256(color)?$/i.test(env.TERM)) {
		return 2;
	}

	if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
		return 1;
	}

	if ('COLORTERM' in env) {
		return 1;
	}

	return min;
}

function getSupportLevel(stream) {
	const level = supportsColor(stream, stream && stream.isTTY);
	return translateLevel(level);
}

var supportsColor_1 = {
	supportsColor: getSupportLevel,
	stdout: translateLevel(supportsColor(true, tty.isatty(1))),
	stderr: translateLevel(supportsColor(true, tty.isatty(2)))
};

function parseVersion(versionString) {
	if (/^\d{3,4}$/.test(versionString)) {
		// Env var doesn't always use dots. example: 4601 => 46.1.0
		const m = /(\d{1,2})(\d{2})/.exec(versionString);
		return {
			major: 0,
			minor: parseInt(m[1], 10),
			patch: parseInt(m[2], 10)
		};
	}

	const versions = (versionString || '').split('.').map(n => parseInt(n, 10));
	return {
		major: versions[0],
		minor: versions[1],
		patch: versions[2]
	};
}

function supportsHyperlink(stream) {
	const {env} = process;

	if ('FORCE_HYPERLINK' in env) {
		return !(env.FORCE_HYPERLINK.length > 0 && parseInt(env.FORCE_HYPERLINK, 10) === 0);
	}

	if (hasFlag('no-hyperlink') || hasFlag('no-hyperlinks') || hasFlag('hyperlink=false') || hasFlag('hyperlink=never')) {
		return false;
	}

	if (hasFlag('hyperlink=true') || hasFlag('hyperlink=always')) {
		return true;
	}

	// If they specify no colors, they probably don't want hyperlinks.
	if (!supportsColor_1.supportsColor(stream)) {
		return false;
	}

	if (stream && !stream.isTTY) {
		return false;
	}

	if (process.platform === 'win32') {
		return false;
	}

	if ('NETLIFY' in env) {
		return true;
	}

	if ('CI' in env) {
		return false;
	}

	if ('TEAMCITY_VERSION' in env) {
		return false;
	}

	if ('TERM_PROGRAM' in env) {
		const version = parseVersion(env.TERM_PROGRAM_VERSION);

		switch (env.TERM_PROGRAM) {
			case 'iTerm.app':
				if (version.major === 3) {
					return version.minor >= 1;
				}

				return version.major > 3;
			// No default
		}
	}

	if ('VTE_VERSION' in env) {
		// 0.50.0 was supposed to support hyperlinks, but throws a segfault
		if (env.VTE_VERSION === '0.50.0') {
			return false;
		}

		const version = parseVersion(env.VTE_VERSION);
		return version.major > 0 || version.minor >= 50;
	}

	return false;
}

var supportsHyperlinks = {
	supportsHyperlink,
	stdout: supportsHyperlink(process.stdout),
	stderr: supportsHyperlink(process.stderr)
};

function terminalLink(text, url, {target = 'stdout', ...options} = {}) {
	if (!supportsHyperlinks[target]) {
		// If the fallback has been explicitly disabled, don't modify the text itself.
		if (options.fallback === false) {
			return text;
		}

		return typeof options.fallback === 'function' ? options.fallback(text, url) : `${text} (\u200B${url}\u200B)`;
	}

	return ansiEscapes.link(text, url);
}

terminalLink.isSupported = supportsHyperlinks.stdout;
terminalLink.stderr = (text, url, options = {}) => terminalLink(text, url, {target: 'stderr', ...options});
terminalLink.stderr.isSupported = supportsHyperlinks.stderr;

function ansiRegex({onlyFirst = false} = {}) {
	const pattern = [
		'[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)',
		'(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))'
	].join('|');

	return new RegExp(pattern, onlyFirst ? undefined : 'g');
}

function stripAnsi(string) {
	if (typeof string !== 'string') {
		throw new TypeError(`Expected a \`string\`, got \`${typeof string}\``);
	}

	return string.replace(ansiRegex(), '');
}

class Stash {
  constructor() {
    this.stash = [];
  }

  push(log, {
    extra = false
  } = {}) {
    this.stash.push({
      body: log,
      extra
    });
  }

  toString({
    extra = true
  } = {}) {
    return stripAnsi(this.stash.filter(item => extra ? true : !item.extra).map(item => item.body).join('\n'));
  }

  toCLIString() {
    return this.stash.map(item => item.body).join('\n');
  }

  render() {
    console.log(this.toCLIString());
  }

}
function makeTitle(color, title, ...rest) {
  return color(`# ${title}`) + (rest.length > 0 ? ' ' + color(rest.join(' ')) : '');
}

const {
  run: runEnvinfo
} = envinfo;
async function genEnv(envinfo, pkg) {
  const env = await runEnvinfo(envinfo != null ? envinfo : {
    System: ["OS"],
    Binaries: ["Node"]
  }, {
    json: true,
    showNotFound: true
  });
  const res = [];
  res.push(makeTitle(chalk.green, "Environment"));
  res.push(`- ${pkg.name}: ${pkg.version}`);
  res.push(Object.entries(JSON.parse(env)).reduce((s, i) => [...s, ...Object.entries(i[1]).map(([k, v]) => [`${i[0]} > ${k}`, v])], []).map(([k, v]) => `- ${k}: ${parseEnvInfo(v)}`).join("\n"));
  return chalk.green(res.join("\n"));
}

function parseEnvInfo(v) {
  if (typeof v === "string") {
    return v;
  } else if (typeof v === "object" && "version" in v) {
    return `${v.version}${v.path ? ` - ${v.path}` : ""}`;
  } else if (Array.isArray(v)) {
    return v.join(", ");
  } else {
    return JSON.stringify(v);
  }
}

async function findIssues(q, repo) {
  const query = `repo:${repo} ${q}`;

  try {
    const res = await fetch(`https://api.github.com/search/issues?q=${encodeURIComponent(query)}&per_page=3`).then(res => res.json());
    return res == null ? void 0 : res.items;
  } catch (err) {
    return [];
  }
}
function guessRepo(str) {
  var _$exec;

  return (_$exec = /(?:(?<=github\.com\/)|^)([\w\-_]+\/[\w.\-_]+)/.exec(str)) == null ? void 0 : _$exec[1];
}
function linkToNewIssue(repo, body) {
  return `https://github.com/${repo}/issues/new${body ? `?body=${encodeURIComponent(body)}` : ''}`;
}

function readJSON(path) {
  return JSON.parse(readFileSync(path, "utf8"));
}
function getModulePackagePath(caller) {
  return pkgUp.sync({
    cwd: dirname(caller)
  });
}

class EpicfailError extends Error {
  constructor(message, option = {}) {
    super(message);
    this.epicfail = void 0;
    if (option.name) this.name = option.name;
    this.epicfail = option;
  }

}
function fail(message, Option = {}) {
  throw new EpicfailError(message instanceof Error ? message.message : message, Option);
}
function logAndExit(message, option = {}) {
  fail(message, _extends({}, {
    stacktrace: false,
    message: false,
    env: false
  }, option));
}
function epicfail(moduleEntrypoint, cliFlags = {}) {
  var _ref, _ref2, _ref3, _pkg$bugs$url, _pkg$bugs, _pkg$bugs2;

  const pkgPath = getModulePackagePath(moduleEntrypoint);
  if (!pkgPath) return;
  const pkg = readJSON(pkgPath);
  const reporterURL = (_ref = (_ref2 = (_ref3 = (_pkg$bugs$url = pkg == null ? void 0 : (_pkg$bugs = pkg.bugs) == null ? void 0 : _pkg$bugs.url) != null ? _pkg$bugs$url : pkg == null ? void 0 : (_pkg$bugs2 = pkg.bugs) == null ? void 0 : _pkg$bugs2.email) != null ? _ref3 : pkg == null ? void 0 : pkg.bugs) != null ? _ref2 : pkg == null ? void 0 : pkg.homepage) != null ? _ref : pkg == null ? void 0 : pkg.author;
  const repo = guessRepo(reporterURL);

  const handleError = async (err, ...rest) => {
    var _err$epicfail;

    // handle error
    if (!(err instanceof Error)) {
      err = new Error(JSON.stringify(err, null, 2));
    }

    const {
      stacktrace = true,
      issues = false,
      message = true,
      env,
      onError,
      assertExpected = () => false
    } = _extends({}, cliFlags, (_err$epicfail = err.epicfail) != null ? _err$epicfail : {});

    if (await Promise.resolve(assertExpected(err))) {
      return logAndExit(err);
    }

    const stash = new Stash();
    const eventID = onError ? onError(err, ...rest) : undefined; // show error message

    stash.push(renderError(err)); // show stack trace

    if (stacktrace && err.stack) {
      stash.push(renderStacktrace(err.stack), {
        extra: true
      });
    } // show additional env info


    if (env !== false) {
      stash.push(await renderEnv(env, pkg));
    } // search related issues


    if (issues && repo) {
      const res = await renderIssues(err.message, repo);
      if (res) stash.push(res);
    } // guide to bug tracker


    if (message && reporterURL) {
      stash.push(renderBugTracker(reporterURL, stash, repo, eventID));
    }

    stash.render();
  };

  process.on("unhandledRejection", handleError);
  process.on("uncaughtException", async (...args) => {
    await handleError(...args);
    process.exit(0);
  });
}

function renderError(err) {
  const title = err.name;
  return (title !== "Error" ? makeTitle(chalk.red, title) + "\n" : "") + chalk.red(err.message);
}

function renderStacktrace(stack) {
  return chalk.gray(`
\`\`\`
${stack}
\`\`\``);
}

async function renderEnv(env, pkg) {
  return "\n" + (await genEnv(env, pkg));
}

async function renderIssues(message, repo) {
  const issues = await findIssues(message, repo);
  let res = [];

  if (issues && issues.length > 0) {
    res.push("\n" + makeTitle(chalk.white, "Issues"));
    res.push(issues.map(issue => `${chalk.green(`#${issue.number}`)} ${issue.title}`).join("\n"));
  }

  return res.join("\n") || undefined;
}

function renderBugTracker(reporterURL, stash, repo, eventID) {
  let detailedURL = reporterURL;

  if (repo) {
    let link = linkToNewIssue(repo, stash.toString());
    if (link.length > 2000) link = linkToNewIssue(repo, stash.toString({
      extra: false
    }));
    detailedURL = link;
  }

  return `\nIf you think this is a bug, please report at ${terminalLink(chalk.yellow(reporterURL), detailedURL, {
    fallback: false
  })} along with the information above${eventID ? ` and event id ${chalk.bold.magenta(eventID)}` : ""}.`;
}

export { EpicfailError, epicfail, fail, logAndExit };
//# sourceMappingURL=index.module.js.map
